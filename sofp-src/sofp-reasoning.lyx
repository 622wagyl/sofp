#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.15cm
\rightmargin 1.3cm
\bottommargin 1.3cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Reasoning about code.
 Techniques of symbolic derivation
\begin_inset CommandInset label
LatexCommand label
name "chap:Reasoning-about-code"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{{\color{teal}#1}}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\end_layout

\begin_layout Standard
In previous chapters, we have performed symbolic derivations of laws for
 different functions.
 To make those derivations more manageable, we have gradually introduced
 special notations and techniques of reasoning.
 This chapter is an in-depth summary of these notations and techniques.
\end_layout

\begin_layout Section
Mathematical code notation
\end_layout

\begin_layout Subsection
Notation for the eight code constructions
\end_layout

\begin_layout Standard
The eight basic constructions introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are supported by all functional programming (FP) languages and serve as
 a foundation for coding.
 All major FP tricks and techniques can be implemented using only these
 constructions.
 The code notation for these eight constructions is summarized in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Mathematical-notation-for-basic-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We will now look at each of the constructions in turn.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Constructions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala examples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Code notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Create a constant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
()
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
true
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $\text{true}$
\end_inset

, 
\begin_inset Formula $\text{"abc"}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Use a given argument
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
def f(x: A) = { ...
 x ...
 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x^{:A})\triangleq...~x~...$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Create a function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
(x: A) => expr(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}\rightarrow\text{expr}(x)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Use a function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
f(x)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
x.pipe(f)
\end_layout

\end_inset

 (Scala 2.13)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x)$
\end_inset

 or 
\begin_inset Formula $x\triangleright f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Create a tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
val p: (A, B) = (a, b)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $p^{:A\times B}\triangleq a\times b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Use a tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
p._1
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
p._2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $p\triangleright\nabla_{1}$
\end_inset

 or 
\begin_inset Formula $p\triangleright\nabla_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Create a disjunctive value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
Left[A, B](x)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\size small
Right[A, B](y)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Use a disjunctive value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset space \hspace*{}
\length -1.3line%
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset VSpace 14baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\size small
val p: Either[A, B] = ...
 
\end_layout

\begin_layout Plain Layout

\size small
val q: C = p match {
\end_layout

\begin_layout Plain Layout

\size small
    case Left(x)   => f(x)
\end_layout

\begin_layout Plain Layout

\size small
    case Right(y)  => g(y)
\end_layout

\begin_layout Plain Layout

\size small
}
\end_layout

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset


\end_layout

\end_inset

 
\begin_inset space \hspace*{}
\length -0.9line%
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $q^{:C}\triangleq p^{:A+B}\triangleright\begin{array}{|c||c|}
 & C\\
\hline A & f\\
B & g
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Mathematical notation for the eight basic code constructions.
\begin_inset CommandInset label
LatexCommand label
name "tab:Mathematical-notation-for-basic-code-constructions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
1) Create a constant
\end_layout

\begin_layout Standard
At any place in code, we may use a fixed constant value of a fixed type,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 We may also use a 
\begin_inset Quotes eld
\end_inset

named unit
\begin_inset Quotes erd
\end_inset

, e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 for any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 All named unit values are denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 and are viewed as having type 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 
\end_layout

\begin_layout Standard
With this construction, we can create 
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset

constant functions (functions that ignore their argument):
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def c_1(x: String): Int = 123
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
c_{1}(x^{:\text{String}})\triangleq123\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph
2) Use a given argument
\end_layout

\begin_layout Standard
In any expression that has a bound variable (e.g.
\begin_inset space ~
\end_inset

body of a function with a bound argument), we may use the bound variable
 at any place, as many times as we need.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def c_2[A](x: String, y: Int): Int = 123 + y + y
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
c_{2}(x^{:\text{String}},y^{:\text{Int}})\triangleq123+y+y\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph
3) Create a function
\end_layout

\begin_layout Standard
We can always make a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr }
\end_layout

\end_inset

 out of a variable, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, and any expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 that may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a free variable (i.e.
\begin_inset space ~
\end_inset

a variable that is expected to be already defined outside the expression).
 E.g.
\begin_inset space ~
\end_inset

the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123 + y + y
\end_layout

\end_inset

 uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 as a free variable because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123 + y + y
\end_layout

\end_inset

 only makes sense if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 is already defined.
 So, we can create a nameless function
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ y: Int => 123 + y + y }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
y^{:\text{Int}}\rightarrow123+y+y\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Standard
If the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 already contains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a bound variable, there will be a name clash; it is helpful to rename
 bound variables to avoid it.
 As an example, consider an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr == { x => x }
\end_layout

\end_inset

 that already contains a nameless function with argument called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 If we want to make a function out of that expression, we could write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => { x => x }
\end_layout

\end_inset

, but it would be confusing.
 It is better to rename the bound variables inside 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

, e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr == { z => z }
\end_layout

\end_inset

, to avoid the name clash:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f = { x: Int => { z => z } }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
f\triangleq x^{:\text{Int}}\rightarrow z\rightarrow z\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph
4) Use a function
\end_layout

\begin_layout Standard
If a function is already defined, we can use it by applying it to an argument.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f = { y: Int => 123 + y + y }
\end_layout

\begin_layout Plain Layout

f(100)  // Evaluates to 323.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset Formula 
\[
f\triangleq y^{:\text{Int}}\rightarrow123+y+y\quad,\quad\quad f(100)=323\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph

5) Create a tuple
\end_layout

\begin_layout Standard
Given two values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B
\end_layout

\end_inset

, we can always create the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

, and the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(b, a)
\end_layout

\end_inset

 as well.
 In the code notation, those tuples are written as 
\begin_inset Formula $a\times b$
\end_inset

 and 
\begin_inset Formula $b\times a$
\end_inset

.
\end_layout

\begin_layout Paragraph

6) Use a tuple
\end_layout

\begin_layout Standard
Given a tuple of, say, two values, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p == (a, b)
\end_layout

\end_inset

, we can extract each of the values.
 The Scala syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2
\end_layout

\end_inset

 corresponds to the code notation 
\begin_inset Formula $p\triangleright\nabla_{1}$
\end_inset

 and 
\begin_inset Formula $p\triangleright\nabla_{2}$
\end_inset

.
 The auxiliary functions 
\begin_inset Formula $\nabla_{i}$
\end_inset

 (where 
\begin_inset Formula $i=1,2,...$
\end_inset

) may be used for tuples of any size.
 Example code defining these functions:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def project_1[A, B]: ((A, B)) => A = {
\end_layout

\begin_layout Plain Layout

    case (a, b) => a
\end_layout

\begin_layout Plain Layout

} // Same as `_._1`
\end_layout

\begin_layout Plain Layout

def project_2[A, B]: ((A, B)) => B = {
\end_layout

\begin_layout Plain Layout

    case (a, b) => b
\end_layout

\begin_layout Plain Layout

} // Same as `_._2`
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace 55baselineskip%
\end_inset


\begin_inset Formula 
\[
\nabla_{1}^{A,B}\triangleq a^{:A}\times b^{:B}\rightarrow a\quad,
\]

\end_inset


\begin_inset Formula 
\[
\nabla_{2}^{A,B}\triangleq a^{:A}\times b^{:B}\rightarrow b\quad.
\]

\end_inset


\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\begin_layout Standard
The code notation 
\begin_inset Formula $a\times b$
\end_inset

 is used in an 
\emph on
argument
\emph default
 of a function to destructure a tuple.
\end_layout

\begin_layout Paragraph

7) Create a disjunctive value
\end_layout

\begin_layout Standard
If a disjunctive type such as 
\begin_inset Formula $A+B+C$
\end_inset

 has been defined in Scala, its named 
\begin_inset Quotes eld
\end_inset

constructors
\begin_inset Quotes erd
\end_inset

 (i.e.
\begin_inset space ~
\end_inset

case classes) are used to create values of the type:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait S
\end_layout

\begin_layout Plain Layout

final case class P(w: Int, x: Int)  extends S
\end_layout

\begin_layout Plain Layout

final case class Q(y: String)       extends S
\end_layout

\begin_layout Plain Layout

final case class R(z: Int)          extends S
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val s: S = P(10, 20)  // Create a value of S.
\end_layout

\begin_layout Plain Layout

val t: S = R(30)      // One more value of S.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace 35baselineskip%
\end_inset


\begin_inset Formula 
\[
S\triangleq\text{Int}\times\text{Int}+\text{String}+\text{Int}\quad,
\]

\end_inset


\begin_inset Formula 
\begin{align*}
s^{:S} & \triangleq10\times20+\bbnum 0^{:\text{String}}+\bbnum 0^{:\text{Int}}\quad,\\
t^{:S} & \triangleq\bbnum 0^{:\text{Int}\times\text{Int}}+\bbnum 0^{:\text{String}}+30\quad.
\end{align*}

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
The code notation for disjunctive values, e.g.
\begin_inset space ~
\end_inset


\begin_inset Formula $\bbnum 0+\bbnum 0+x$
\end_inset

, is more verbose than the Scala syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R(x)
\end_layout

\end_inset

.
 The advantage is that we may explicitly annotate all types and show clearly
 the part of the disjunction that we are creating.
 Another advantage is that the notation 
\begin_inset Formula $\bbnum 0+\bbnum 0+x$
\end_inset

 is similar to a row vector, 
\begin_inset Formula $\,\begin{array}{|ccc|}
\bbnum 0 & \bbnum 0 & x\end{array}\:$
\end_inset

, which is well adapted to the matrix notation for functions.
\end_layout

\begin_layout Paragraph

8) Use a disjunctive value

\end_layout

\begin_layout Standard
Once created, disjunctive values can be used in a pattern matching expression
 (Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

).
 Functions that take a disjunctive value as an argument may be written without
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 keyword:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Option[Int] => Option[Int] = {
\end_layout

\begin_layout Plain Layout

  case None      => Some(100)
\end_layout

\begin_layout Plain Layout

  case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -145baselineskip%
\end_inset


\begin_inset Formula 
\[
f^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\begin_layout Standard
This example will help us see in detail how such functions are written in
 the matrix notation.
\end_layout

\begin_layout Standard
Each row of the matrix corresponds to a part of the disjunctive type matched
 by one of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 In this example, the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int]
\end_layout

\end_inset

 has two parts, the named unit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

) and the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[Int]
\end_layout

\end_inset

, which is equivalent to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 So, the matrix has two rows labeled 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $\text{Int}$
\end_inset

.
\end_layout

\begin_layout Standard
The columns of the matrix correspond to the parts of the disjunctive type
 
\emph on
returned
\emph default
 by the function.
 In this example, the return type is also 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int]
\end_layout

\end_inset

, that is, 
\begin_inset Formula $\bbnum 1+\text{Int}$
\end_inset

 in the type notation, so the matrix has two columns labeled 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $\text{Int}$
\end_inset

.
 
\end_layout

\begin_layout Standard
What are the matrix elements? The idea of the matrix notation is to translate
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions line by line from the Scala code.
 Look at the first line as if it were a standalone partial function,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ case None => Some(100) }
\end_layout

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 is a named unit, this function is written in the code notation as 
\begin_inset Formula $1\rightarrow\bbnum 0+100^{:\text{Int}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The second line is written in the form of a partial function as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ case Some(x) => Some(x / 2) }
\end_layout

\end_inset

The only pattern variable on the left side is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, so we can denote this function by 
\begin_inset Formula $x^{:\text{Int}}\rightarrow\bbnum 0+(x/2)^{:\text{Int}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
To obtain the matrix notation, we may simply write the two partial functions
 in the two rows:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Option[Int] => Option[Int] = {
\end_layout

\begin_layout Plain Layout

  case None      => Some(100)
\end_layout

\begin_layout Plain Layout

  case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -135baselineskip%
\end_inset


\begin_inset Formula 
\[
f^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\begin{array}{|c||c|}
 & \bbnum 1+\text{Int}\\
\hline \bbnum 1 & 1\rightarrow\bbnum 0+100\\
\text{Int} & x\rightarrow\bbnum 0+\frac{x}{2}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
This is a valid matrix notation for the function 
\begin_inset Formula $f$
\end_inset

.
 So far, the matrix has two rows and one column.
 However, we notice that each row has a value that is 
\emph on
known
\emph default
 to be in a specific part of the disjunctive type 
\begin_inset Formula $\bbnum 1+\text{Int}$
\end_inset

 (in this example, both rows happen to return values of type 
\begin_inset Formula $\bbnum 0+\text{Int}$
\end_inset

).
 So, we can split the matrix into two columns and obtain a clearer and more
 convenient notation for this function:
\begin_inset Formula 
\[
f^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset

The void type 
\begin_inset Formula $\bbnum 0$
\end_inset

 is written symbolically to denote that the indicated disjunctive part is
 not returned.
 In this way, matrix notation can easily express functions that work with
 disjunctive types.
\end_layout

\begin_layout Standard
Partial functions are written in the matrix notation by writing 
\begin_inset Formula $\bbnum 0$
\end_inset

 in the invalid column:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val get: Option[A] => A = {
\end_layout

\begin_layout Plain Layout

  case Some(x) => x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -135baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{get}^{:\bbnum 1+A\rightarrow A}\triangleq\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & x^{:A}\rightarrow x
\end{array}=\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & \text{id}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression can be written as an application of a partial function.
 
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val p: Option[Int] = Some(64)
\end_layout

\begin_layout Plain Layout

p match {
\end_layout

\begin_layout Plain Layout

  case None      => Some(100)
\end_layout

\begin_layout Plain Layout

  case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -275baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\begin_inset Formula 
\[
p^{:\bbnum 1+\text{Int}}\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset

It is convenient to put the argument to the left of the partial function,
 as in the Scala code.
\end_layout

\begin_layout Standard
The matrix notation allows us to compute such function applications directly.
 We view the disjunctive value as a 
\begin_inset Quotes eld
\end_inset

row vector
\begin_inset Quotes erd
\end_inset

 and follow the standard rules for the vector-matrix product:
\begin_inset Formula 
\[
(\bbnum 0+64)^{:\bbnum 1+\text{Int}}\triangleright\,\begin{array}{||cc|}
\bbnum 0 & 1\rightarrow100\\
\bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 64\end{array}\,\triangleright\,\begin{array}{||cc|}
\bbnum 0 & 1\rightarrow100\\
\bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 64\triangleright(x\rightarrow\frac{x}{2})\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 32\end{array}\quad.
\]

\end_inset

We just need to omit any terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

 and use the pipe (
\begin_inset Formula $\triangleright$
\end_inset

) instead of multiplication.
 We also omitted type annotations on the matrix, since we already checked
 that the types match.
\end_layout

\begin_layout Subsection
Notation for the composition of functions and for liftings
\end_layout

\begin_layout Section
Derivation techniques
\end_layout

\end_body
\end_document
