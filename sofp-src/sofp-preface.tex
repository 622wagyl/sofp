
\addchap{Preface}

\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%
The goal of this book is to teach programmers how to reason mathematically
about types and code, in a way that is directly relevant to software
practice.

The material is presented at medium to advanced level. Readers will
need to learn difficult concepts through prolonged mental concentration
and effort. The book requires a certain amount of mathematical experience,
at the level of familiarity with high-school algebra.

The first part is introductory and may be suitable for beginners in
programming. Starting from Chapter~\ref{chap:3-3-The-formal-logic-curry-howard},
the material becomes unsuitable for beginners. 

The presentation in this book is self-contained, defining and explaining
all required notations, concepts, and Scala language features from
scratch. The emphasis is on clarity and understandability of all examples,
mathematical notions, derivations, and code. To achieve a clearer
presentation of the material, the book uses some non-standard notations
(Appendix~\ref{chap:Appendix-Notations}) and terminology (Appendix~\ref{chap:Appendix-Glossary-of-terms}). 

The vision of this book is to explain the mathematical principles
that guide the practice of functional programming \textendash{} that
is, help people to write code. Therefore, all mathematical developments
in this book are motivated and justified by practical programming
issues and are accompanied by code examples that illustrate their
usage. For instance, the equational laws for standard typeclasses
(functor, applicative, monad, etc.) are first motivated heuristically
with code examples. Only then a set of mathematical equations is derived
and the laws are formulated as equations.

Each new concept or technique is clafiried by solved examples and
exercises. Answers to exercises are not provided, but it is verified
that the exercises are doable and free of errors. More difficult examples
and exercises are marked by an asterisk ({*}).

A software engineer needs to know only a few fragments of mathematical
theory; namely, the fragments that answer questions arising in the
practice of functional programming. So the theoretical material is
kept to the minimum; \emph{ars longa, vita brevis}. (Chapter~\ref{chap:Applied-functional-type}
presents more discussion of the scope of the required theory.) Mathematical
generalizations are not pursued beyond practical relevance or immediate
pedagogical usefulness. This limits the scope of required mathematical
knowledge to bare rudiments of category theory, type theory, and formal
logic. For instance, this book does not mention ``introduction/elimination
rules'', ``strong normalization'', ``complete partial order domains'',
``adjoint functors'', ``pullbacks'', ``topoi'', or ``algebras'',
because learning these concepts will not help a functional programmer
write code. This book is also not an introduction to today's research
in the theory of programming languages. Instead, the focus is on practically
useful material \textendash{} including some rarely mentioned constructions,
such as the ``filterable functor'' and ``applicative contrafunctor''
typeclasses. 

All code examples are intended only for explanation and illustration,
and are not optimized for performance or stack safety.

The author thanks Joseph Kim and Jim Kleck for going through the exercises
and reporting some errors in earlier versions of this book.

\addsec{Formatting conventions used in this book}
\begin{itemize}
\item Text in boldface indicates a new concept or term that is being defined.
Text in italics is a logical emphasis. Example:
\end{itemize}
\begin{quotation}
An \textbf{aggregation\index{aggregation}} is a function from a list
of values to a \emph{single} value.
\end{quotation}
\begin{itemize}
\item Sample Scala code is written inline using a small monospaced font,
such as this: \lstinline!val a = "xyz"!. Longer code examples are
written in separate code blocks, which may also show the output from
the Scala interpreter for certain lines of code:
\end{itemize}
\begin{lstlisting}[mathescape=true]
val s = (1 to 10).toList

scala> s.product
res0: Int = 3628800 
\end{lstlisting}

\begin{itemize}
\item In the introductory chapters, type expressions and code examples are
written in the syntax of Scala. Starting from Chapters~\ref{chap:Higher-order-functions}\textendash \ref{chap:3-3-The-formal-logic-curry-howard},
the book introduces a new notation for types where e.g.~the Scala
type expression \lstinline!((A, B)) => Option[A]! is written as $A\times B\rightarrow\bbnum 1+A$.
Also, a new notation for code is introduced and developed in Chapters~\ref{chap:3-3-The-formal-logic-curry-howard}\textendash \ref{chap:Functors,-contrafunctors,-and}
for easier reasoning about laws. For example, the functor composition
law is written in the code notation as
\[
f^{\uparrow L}\bef g^{\uparrow L}=\left(f\bef g\right)^{\uparrow L}\quad,
\]
where $L$ is a functor and $f^{:A\rightarrow B}$ and $g^{:B\rightarrow C}$
are arbitrary functions of the specified types. The symbol $\bef$
denotes the forward composition of functions (Scala's \lstinline!andThen!
method). Appendix~\ref{chap:Appendix-Notations} summarizes the notation
conventions for types and code.
\item Derivations of laws are written in a two-column notation where the
right column contains formulas in the code notation and the left column
gives an explanation or indicates the property or law used to derive
the expression at right. A green underline in the \emph{previous}
expression shows the part to be rewritten using the indicated law
or equation:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{M}:}\quad & \gunderline{\text{pu}_{M}^{\uparrow\text{Id}}}\bef\text{pu}_{M}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{lifting to the identity functor}:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{left identity law for }M:}\quad & =\text{pu}_{M}\quad.
\end{align*}
A green underline is sometimes also used at the \emph{last} step of
the derivation, to indicate the part of the expression that resulted
from the most recent rewriting.
\end{itemize}

