
\chapter{Reasoning about code. Techniques of symbolic derivation\label{chap:Reasoning-about-code}}

\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%

In previous chapters, we have performed symbolic derivations of laws
for different functions. To make those derivations more manageable,
we have gradually introduced special notations and techniques of reasoning.
This chapter is an in-depth summary of these notations and techniques.

\section{Mathematical code notation}

\subsection{Notation for the eight code constructions}

The eight basic constructions introduced in Section~\ref{subsec:The-rules-of-proof}
are supported by all functional programming (FP) languages and serve
as a foundation for coding. All major FP tricks and techniques can
be implemented using only these constructions. The code notation for
these eight constructions is summarized in Table~\ref{tab:Mathematical-notation-for-basic-code-constructions}.
We will now look at each of the constructions in turn.

\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{\small{}Constructions} & \textbf{\small{}Scala examples} & \textbf{\small{}Code notation}\tabularnewline
\hline 
\hline 
{\small{}Create a constant} & {\small{}}\lstinline!()!{\small{} or }\lstinline!true!{\small{}
or }\lstinline!"abc"! & {\small{}$1$, $\text{true}$, $\text{"abc"}$}\tabularnewline
\hline 
{\small{}Use a given argument} & {\small{}}\lstinline!def f(x: A) = { ... x ... }! & {\small{}$f(x^{:A})\triangleq...~x~...$}\tabularnewline
\hline 
{\small{}Create a function} & {\small{}}\lstinline!(x: A) => expr(x)! & {\small{}$x^{:A}\rightarrow\text{expr}(x)$}\tabularnewline
\hline 
{\small{}Use a function} & {\small{}}\lstinline!f(x)!{\small{} or }\lstinline!x.pipe(f)!{\small{}
(Scala 2.13)} & {\small{}$f(x)$ or $x\triangleright f$}\tabularnewline
\hline 
{\small{}Create a tuple} & {\small{}}\lstinline!val p: (A, B) = (a, b)! & {\small{}$p^{:A\times B}\triangleq a\times b$}\tabularnewline
\hline 
{\small{}Use a tuple} & {\small{}}\lstinline!p._1!{\small{} or }\lstinline!p._2! & {\small{}$p\triangleright\nabla_{1}$ or $p\triangleright\nabla_{2}$}\tabularnewline
\hline 
{\small{}Create a disjunctive value} & {\small{}}\lstinline!Left[A, B](x)!{\small{} or }\lstinline!Right[A, B](y)! & {\small{}$x^{:A}+\bbnum 0^{:B}$ or $\bbnum 0^{:A}+y^{:B}$}\tabularnewline
\hline 
{\small{}Use a disjunctive value} & {\small{}\hspace*{-0.013\linewidth}}%
\begin{minipage}[c][1\totalheight][b]{0.33\columnwidth}%
{\small{}\vspace{0.14\baselineskip}
}
\begin{lstlisting}
val p: Either[A, B] = ... 
val q: C = p match {
    case Left(x)   => f(x)
    case Right(y)  => g(y)
}
\end{lstlisting}
{\small{}\vspace{-0.1\baselineskip}
}%
\end{minipage}{\small{} \hspace*{-0.009\linewidth}} & {\small{}$q^{:C}\triangleq p^{:A+B}\triangleright\begin{array}{|c||c|}
 & C\\
\hline A & f\\
B & g
\end{array}$}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Mathematical notation for the eight basic code constructions.\label{tab:Mathematical-notation-for-basic-code-constructions}}
\end{table}


\paragraph{1) Create a constant}

At any place in code, we may use a fixed constant value of a fixed
type, such as \lstinline!Int!, \lstinline!String!, or \lstinline!Unit!.
We may also use a ``named unit'', e.g.~\lstinline!None! of type
\lstinline!Option[A]! for any type \lstinline!A!. All named unit
values are denoted by \lstinline!1! and are viewed as having type
$\bbnum 1$. 

With this construction, we can create \index{constant function}constant
functions (functions that ignore their argument):

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.65\baselineskip}
\begin{lstlisting}
def c_1(x: String): Int = 123
\end{lstlisting}

\vspace{-0.25\baselineskip}
\end{wrapfigure}%

~\vspace{-0.35\baselineskip}
\[
c_{1}(x^{:\text{String}})\triangleq123\quad.
\]
\vspace{-0.85\baselineskip}


\paragraph{2) Use a given argument}

In any expression that has a bound variable (e.g.~body of a function
with a bound argument), we may use the bound variable at any place,
as many times as we need.

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.65\baselineskip}
\begin{lstlisting}
def c_2[A](x: String, y: Int): Int = 123 + y + y
\end{lstlisting}

\vspace{-0.25\baselineskip}
\end{wrapfigure}%

~\vspace{-0.35\baselineskip}
\[
c_{2}(x^{:\text{String}},y^{:\text{Int}})\triangleq123+y+y\quad.
\]
\vspace{-0.85\baselineskip}


\paragraph{3) Create a function}

We can always make a nameless function \lstinline!{ x => expr }!
out of a variable, say \lstinline!x!, and any expression \lstinline!expr!
that may use \lstinline!x! as a free variable (i.e.~a variable that
is expected to be already defined outside the expression). E.g.~the
expression \lstinline!123 + y + y! uses \lstinline!y! as a free
variable because \lstinline!123 + y + y! only makes sense if \lstinline!y!
is already defined. So, we can create a nameless function

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.65\baselineskip}
\begin{lstlisting}
{ y: Int => 123 + y + y }
\end{lstlisting}

\vspace{-0.25\baselineskip}
\end{wrapfigure}%

~\vspace{-0.35\baselineskip}
\[
y^{:\text{Int}}\rightarrow123+y+y\quad.
\]
\vspace{-0.85\baselineskip}

If the expression \lstinline!expr! already contains \lstinline!x!
as a bound variable, there will be a name clash; it is helpful to
rename bound variables to avoid it. As an example, consider an expression
\lstinline!expr == { x => x }! that already contains a nameless function
with argument called \lstinline!x!. If we want to make a function
out of that expression, we could write \lstinline!x => { x => x }!,
but it would be confusing. It is better to rename the bound variables
inside \lstinline!expr!, e.g.~\lstinline!expr == { z => z }!, to
avoid the name clash:

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.65\baselineskip}
\begin{lstlisting}
val f = { x: Int => { z => z } }
\end{lstlisting}

\vspace{-0.25\baselineskip}
\end{wrapfigure}%

~\vspace{-0.35\baselineskip}
\[
f\triangleq x^{:\text{Int}}\rightarrow z\rightarrow z\quad.
\]
\vspace{-0.85\baselineskip}


\paragraph{4) Use a function}

If a function is already defined, we can use it by applying it to
an argument.

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.65\baselineskip}
\begin{lstlisting}
val f = { y: Int => 123 + y + y }
f(100)  // Evaluates to 323.
\end{lstlisting}

\vspace{-0.25\baselineskip}
\end{wrapfigure}%

~\vspace{-0.65\baselineskip}
\[
f\triangleq y^{:\text{Int}}\rightarrow123+y+y\quad,\quad\quad f(100)=323\quad.
\]
\vspace{-0.85\baselineskip}


\paragraph{5) Create a tuple}

Given two values \lstinline!a: A! and \lstinline!b: B!, we can always
create the tuple \lstinline!(a, b)!, and the tuple \lstinline!(b, a)!
as well. In the code notation, those tuples are written as $a\times b$
and $b\times a$.

\paragraph{6) Use a tuple}

Given a tuple of, say, two values, \lstinline!p == (a, b)!, we can
extract each of the values. The Scala syntax \lstinline!p._1! and
\lstinline!p._2! corresponds to the code notation $p\triangleright\nabla_{1}$
and $p\triangleright\nabla_{2}$. The auxiliary functions $\nabla_{i}$
(where $i=1,2,...$) may be used for tuples of any size. Example code
defining these functions:

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.85\baselineskip}
\begin{lstlisting}
def project_1[A, B]: ((A, B)) => A = {
    case (a, b) => a
} // Same as `_._1`
def project_2[A, B]: ((A, B)) => B = {
    case (a, b) => b
} // Same as `_._2`
\end{lstlisting}

\vspace{-0.5\baselineskip}
\end{wrapfigure}%

~\vspace{0.55\baselineskip}
\[
\nabla_{1}^{A,B}\triangleq a^{:A}\times b^{:B}\rightarrow a\quad,
\]
\[
\nabla_{2}^{A,B}\triangleq a^{:A}\times b^{:B}\rightarrow b\quad.
\]
\vspace{0.2\baselineskip}

The code notation $a\times b$ is used in an \emph{argument} of a
function to destructure a tuple.

\paragraph{7) Create a disjunctive value}

If a disjunctive type such as $A+B+C$ has been defined in Scala,
its named ``constructors'' (i.e.~case classes) are used to create
values of the type:

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.75\baselineskip}
\begin{lstlisting}
sealed trait S
final case class P(w: Int, x: Int)  extends S
final case class Q(y: String)       extends S
final case class R(z: Int)          extends S

val s: S = P(10, 20)  // Create a value of S.
val t: S = R(30)      // One more value of S.
\end{lstlisting}

\vspace{-0\baselineskip}
\end{wrapfigure}%

~\vspace{0.35\baselineskip}
\[
S\triangleq\text{Int}\times\text{Int}+\text{String}+\text{Int}\quad,
\]
\begin{align*}
s^{:S} & \triangleq10\times20+\bbnum 0^{:\text{String}}+\bbnum 0^{:\text{Int}}\quad,\\
t^{:S} & \triangleq\bbnum 0^{:\text{Int}\times\text{Int}}+\bbnum 0^{:\text{String}}+30\quad.
\end{align*}
\vspace{-0.9\baselineskip}

The code notation for disjunctive values, e.g.~$\bbnum 0+\bbnum 0+x$,
is more verbose than the Scala syntax such as \lstinline!R(x)!. The
advantage is that we may explicitly annotate all types and show clearly
the part of the disjunction that we are creating. Another advantage
is that the notation $\bbnum 0+\bbnum 0+x$ is similar to a row vector,
$\,\begin{array}{|ccc|}
\bbnum 0 & \bbnum 0 & x\end{array}\:$, which is well adapted to the matrix notation for functions.

\paragraph{8) Use a disjunctive value}

Once created, disjunctive values can be used in a pattern matching
expression (Scala's \lstinline!match! / \lstinline!case!). Functions
that take a disjunctive value as an argument may be written without
the \lstinline!match! keyword:

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.65\baselineskip}
\begin{lstlisting}
val f: Option[Int] => Option[Int] = {
  case None      => Some(100)
  case Some(x)   => Some(x / 2)
}
\end{lstlisting}

\vspace{-0.75\baselineskip}
\end{wrapfigure}%

~\vspace{-1.45\baselineskip}
\[
f^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\quad.
\]
\vspace{-0.8\baselineskip}

This example will help us see in detail how such functions are written
in the matrix notation.

Each row of the matrix corresponds to a part of the disjunctive type
matched by one of the \lstinline!case! expressions. In this example,
the disjunctive type \lstinline!Option[Int]! has two parts, the named
unit \lstinline!None! (denoted by $\bbnum 1$) and the case class
\lstinline!Some[Int]!, which is equivalent to the type \lstinline!Int!.
So, the matrix has two rows labeled $\bbnum 1$ and $\text{Int}$.

The columns of the matrix correspond to the parts of the disjunctive
type \emph{returned} by the function. In this example, the return
type is also \lstinline!Option[Int]!, that is, $\bbnum 1+\text{Int}$
in the type notation, so the matrix has two columns labeled $\bbnum 1$
and $\text{Int}$. 

What are the matrix elements? The idea of the matrix notation is to
translate the \lstinline!case! expressions line by line from the
Scala code. Look at the first line as if it were a standalone partial
function,
\begin{lstlisting}
{ case None => Some(100) }
\end{lstlisting}
Since \lstinline!None! is a named unit, this function is written
in the code notation as $1\rightarrow\bbnum 0+100^{:\text{Int}}$. 

The second line is written in the form of a partial function as
\begin{lstlisting}
{ case Some(x) => Some(x / 2) }
\end{lstlisting}
The only pattern variable on the left side is \lstinline!x!, so we
can denote this function by $x^{:\text{Int}}\rightarrow\bbnum 0+(x/2)^{:\text{Int}}$. 

To obtain the matrix notation, we may simply write the two partial
functions in the two rows:

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.65\baselineskip}
\begin{lstlisting}
val f: Option[Int] => Option[Int] = {
  case None      => Some(100)
  case Some(x)   => Some(x / 2)
}
\end{lstlisting}

\vspace{-0.75\baselineskip}
\end{wrapfigure}%

~\vspace{-1.35\baselineskip}
\[
f^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\begin{array}{|c||c|}
 & \bbnum 1+\text{Int}\\
\hline \bbnum 1 & 1\rightarrow\bbnum 0+100\\
\text{Int} & x\rightarrow\bbnum 0+\frac{x}{2}
\end{array}\quad.
\]
\vspace{-0.9\baselineskip}

This is a valid matrix notation for the function $f$. So far, the
matrix has two rows and one column. However, we notice that each row
has a value that is \emph{known} to be in a specific part of the disjunctive
type $\bbnum 1+\text{Int}$ (in this example, both rows happen to
return values of type $\bbnum 0+\text{Int}$). So, we can split the
matrix into two columns and obtain a clearer and more convenient notation
for this function:
\[
f^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\quad.
\]
The void type $\bbnum 0$ is written symbolically to denote that the
indicated disjunctive part is not returned. In this way, matrix notation
can easily express functions that work with disjunctive types.

Partial functions are written in the matrix notation by writing $\bbnum 0$
in the invalid column:

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.65\baselineskip}
\begin{lstlisting}
val get: Option[A] => A = {
  case Some(x) => x
}
\end{lstlisting}

\vspace{-0.75\baselineskip}
\end{wrapfigure}%

~\vspace{-1.35\baselineskip}
\[
\text{get}^{:\bbnum 1+A\rightarrow A}\triangleq\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & x^{:A}\rightarrow x
\end{array}=\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & \text{id}
\end{array}\quad.
\]
\vspace{-0.9\baselineskip}

Scala's \lstinline!match! expression can be written as an application
of a partial function. 

\begin{wrapfigure}{l}{0.5\columnwidth}%
\vspace{-0.85\baselineskip}
\begin{lstlisting}
val p: Option[Int] = Some(64)
p match {
  case None      => Some(100)
  case Some(x)   => Some(x / 2)
}
\end{lstlisting}

\vspace{-2.75\baselineskip}
\end{wrapfigure}%

~\vspace{-0.25\baselineskip}
\[
p^{:\bbnum 1+\text{Int}}\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\quad.
\]
\vspace{-0.1\baselineskip}
It is convenient to put the argument to the left of the partial function,
as in the Scala code.

The matrix notation allows us to compute such function applications
directly. We view the disjunctive value as a ``row vector'' and
follow the standard rules for the vector-matrix product:
\[
(\bbnum 0+64)^{:\bbnum 1+\text{Int}}\triangleright\,\begin{array}{||cc|}
\bbnum 0 & 1\rightarrow100\\
\bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 64\end{array}\,\triangleright\,\begin{array}{||cc|}
\bbnum 0 & 1\rightarrow100\\
\bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 64\triangleright(x\rightarrow\frac{x}{2})\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 32\end{array}\quad.
\]
We just need to omit any terms containing $\bbnum 0$ and use the
pipe ($\triangleright$) instead of multiplication.

\subsection{Notation for the composition of functions and for liftings}

\section{Derivation techniques}
